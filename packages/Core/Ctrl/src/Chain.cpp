/** @file Chain.cpp
 * 
 * 
 * @author	Marek Kopicki
 *
 * @copyright  Copyright (C) 2015 Marek Kopicki, University of Birmingham, UK
 *
 * @license  This file copy is licensed to you under the terms described in
 *           the License.txt file included in this distribution.
 *
 */

#include <Golem/Sys/Context.h>
#include <Golem/Ctrl/Controller.h>
#include <Golem/Ctrl/Chain.h>

//------------------------------------------------------------------------------

using namespace golem;

//------------------------------------------------------------------------------

Chain::Chain(golem::Controller& controller) : controller(controller), context(controller.getContext()) {
}

Chain::~Chain() {
}

void Chain::create(const Desc& desc) {
	if (!desc.isValid())
		throw MsgChainInvalidDesc(Message::LEVEL_CRIT, "Chain::create(): Invalid description");

	name = desc.name;
	index = desc.index;
	indexLocal = desc.indexLocal;
	linkedChainIndex = (U32)desc.linkedChainIndex >= (U32)desc.indexLocal ? Chainspace::Index(Chainspace::Index::UNDEF) : controller.getStateInfo().getChains().begin() + desc.linkedChainIndex;

	jointSeq.clear();
	joints.clear();
	jointCoordSeq.clear();
	for (idx_t i = 0; i < (idx_t)desc.joints.size(); ++i) {
		const Configspace::Index j = controller.getStateInfo().getJoints(index).begin() + i;

		Joint::Desc* pDesc = const_cast<Joint::Desc*>(desc.joints[i].get());
		pDesc->index = j; // index
		pDesc->indexLocal = i; // index within chain
		Joint::Ptr pJoint = pDesc->create(*this); // throws
		jointSeq.push_back(pJoint);
		joints.push_back(pJoint.get());

		for (ExpCoord::Seq::const_iterator j = pJoint->getTrnSeq().begin(); j != pJoint->getTrnSeq().end(); ++j)
			jointCoordSeq.push_back(JointCoord(*j, i));
	}

	customKinematics = desc.customKinematics;
	localPose = desc.localPose;
	referencePose = desc.referencePose;
	
	boundsDescSeq.clear();	
	for (Bounds::Desc::Seq::const_iterator i = desc.bounds.begin(); i != desc.bounds.end(); ++i)
		if (*i != NULL)
			boundsDescSeq.push_back((*i)->clone());
}

//------------------------------------------------------------------------------

Mat34 Chain::getLocalPose() const {
	CriticalSectionWrapper csw(csData);
	return localPose;
}

void Chain::setLocalPose(const Mat34 &localPose) {
	CriticalSectionWrapper csw(csData);
	this->localPose = localPose;
}

Mat34 Chain::getReferencePose() const {
	CriticalSectionWrapper csw(csData);
	return referencePose;
}

void Chain::setReferencePose(const Mat34 &referencePose) {
	CriticalSectionWrapper csw(csData);
	this->referencePose = referencePose;
}		

bool Chain::addBoundsDesc(Bounds::Desc::Ptr pDesc) {
	{
		CriticalSectionWrapper csw(csData);
		boundsDescSeq.push_back(pDesc);
	}

	controller.getCallbackDataSync()->syncChainBoundsDesc(this);

	return true;
}

bool Chain::removeBoundsDesc(const Bounds::Desc* pDesc) {
	Bounds::Desc::Seq::iterator pos = std::find(boundsDescSeq.begin(), boundsDescSeq.end(), pDesc);
	if (pos == boundsDescSeq.end()) {
		context.error("Chain::removeBoundsDesc(): Unable to find bounds description\n");
		return false;
	}
	{
		CriticalSectionWrapper csw(csData);
		boundsDescSeq.erase(pos);
	}

	controller.getCallbackDataSync()->syncChainBoundsDesc(this);

	return true;
}

Bounds::Desc::SeqPtr Chain::getBoundsDescSeq() const {
	CriticalSectionWrapper csw(csData);
	return Bounds::Desc::clone(boundsDescSeq.begin(), boundsDescSeq.end());
}

bool Chain::hasBoundsDesc() const {
	CriticalSectionWrapper csw(csData);
	return !boundsDescSeq.empty();
}

//------------------------------------------------------------------------------

// Generic froward kinematics generated from twist coordinates
//
// n		- number of joints
// cc(i)	- transformation generated by the twist of the i-th joint
// ccini(i)	- initial transformation generated by the twist of the i-th joint
// cctp		- optional transformation generated by the fixed/static tool frame pose 
//
// trn		= cctp*cc(0)*cc(1)* ... *cc(n-2)*cc(n-1)*ccini(n-1)
//
void Chain::chainForwardTransform(const Real* cc, Mat34& trn) const {
	const idx_t numOfJoints = (idx_t)jointSeq.size();
	const idx_t numOfJointCoords = (idx_t)jointCoordSeq.size();
	const Mat34 localPose = getLocalPose();
	Mat34 tmp;

	trn = jointSeq[numOfJoints - 1]->getTrnInit();

	for (idx_t i = numOfJointCoords - 1; i >= 0; --i) {
		tmp.fromTwist(jointCoordSeq[i].trn.twist, cc[jointCoordSeq[i].index]);
		trn.multiply(tmp, trn);
	}

	trn.multiply(localPose, trn);

	//const I32 numOfJoints = (I32)joints.size();
	//const Mat34 localPose = getLocalPose();
	//Mat34 tmp;

	//trn = joints[numOfJoints - 1]->getTrnInit();

	//for (I32 i = numOfJoints - 1; i >= 0; --i) {
	//	tmp.fromTwist(joints[i]->getTrn().twist, cc[i]);
	//	trn.multiply(tmp, trn);
	//}

	//trn.multiply(localPose, trn);
}


// Generic forward transformation for all joints
//
// n		- number of joints
// cc(i)	- transformation generated by the twist of the i-th joint
// ccini(i)	- initial transformation generated by the twist of the i-th joint
// cctp		- optional transformation generated by the fixed/static tool frame pose 
//
// trn[0]	= cc(0)*ccini(0)
// trn[1]	= cc(0)*cc(1)*ccini(1)
// trn[2]	= cc(0)*cc(1)*cc(2)*ccini(2)
// ...
// trn[n-2]	= cc(0)*cc(1)* ... *cc(n-3)*cc(n-2)*ccini(n-2)
// trn[n-1]	= cc(0)*cc(1)* ... *cc(n-3)*cc(n-2)*cc(n-1)*ccini(n-1)*cctp
//
void Chain::jointForwardTransform(const Real* cc, Mat34* trn) const {
	const idx_t numOfJoints = (idx_t)jointSeq.size();
	const idx_t numOfJointCoords = (idx_t)jointCoordSeq.size();
	const Mat34 localPose = getLocalPose();
	Mat34 prev, next;

	prev.fromTwist(jointCoordSeq[0].trn.twist, cc[jointCoordSeq[0].index]);
	trn[jointCoordSeq[0].index] = prev;
	for (idx_t i = 1; i < numOfJointCoords; ++i) {
		next.fromTwist(jointCoordSeq[i].trn.twist, cc[jointCoordSeq[i].index]);
		prev.multiply(prev, next);
		trn[jointCoordSeq[i].index] = prev;
	}

	for (idx_t i = 0; i < numOfJoints; ++i) {
		trn[i].multiply(trn[i], jointSeq[i]->getTrnInit());
		trn[i].multiply(localPose, trn[i]);
	}

	//const U32 numOfJoints = (U32)joints.size();
	//const Mat34 localPose = getLocalPose();
	//
	//trn[0].fromTwist(joints[0]->getTrn().twist, cc[0]);	
	//for (U32 i = 1; i < numOfJoints; ++i) {
	//	trn[i].fromTwist(joints[i]->getTrn().twist, cc[i]);
	//	trn[i].multiply(trn[i - 1], trn[i]);
	//}

	//for (U32 i = 0; i < numOfJoints; ++i) {
	//	trn[i].multiply(trn[i], joints[i]->getTrnInit());
	//	trn[i].multiply(localPose, trn[i]);
	//}
}

//------------------------------------------------------------------------------

// Generic spatial velocity generated from twist coordinates
void Chain::velocitySpatial(const Real* cc, const Real* dcc, Twist& vs) const {
	Mat34 tmp, trn;
	Twist ad;

	const U32 numOfJoints = (U32)joints.size();
	vs.multiply(dcc[0], joints[0]->getTrn().twist);

	trn.setId();
	for (U32 i = 1; i < numOfJoints; ++i) {
		tmp.fromTwist(joints[i - 1]->getTrn().twist, cc[i - 1]);
		trn.multiply(trn, tmp);
		trn.adjointTransform(ad, joints[i]->getTrn().twist);

		vs.multiplyAdd(dcc[i], ad, vs);
	}
}

// Generic body velocity generated from twist coordinates
void Chain::velocityBody(const Real* cc, const Real* dcc, Twist& vb) const {
	Mat34 tmp, trn;
	Twist ad;

	const I32 numOfJoints = (I32)joints.size();
	trn = joints[numOfJoints - 1]->getTrnInit();
	vb.setZero();
	
	for (I32 i = numOfJoints - 1; i >= 0; --i) {
		tmp.fromTwist(joints[i]->getTrn().twist, cc[i]);
		trn.multiply(tmp, trn);
		trn.adjointInverseTransform(ad, joints[i]->getTrn().twist);

		vb.multiplyAdd(dcc[i], ad, vb);
	}
}

// End-effector velocity
void Chain::velocity(const Real* cc, const Real* dcc, Twist& v) const {
	Chain::velocitySpatial(cc, dcc, v);
}

void Chain::velocityFromJacobian(const Twist* jac, const Real* dcc, Twist& v) const {
	const U32 numJoints = (U32)joints.size();
	
	v.setZero();
	for (U32 i = 0; i < numJoints; ++i)
		v.multiplyAdd(dcc[i], jac[i], v);
}

void Chain::velocityFromSpatial(const Mat34& trn, const Twist& vs, Twist& v) const {
	v.v.cross(vs.w, trn.p);
	v.v.add(vs.v, v.v);
	v.w = vs.w;
}

void Chain::velocityFromBody(const Mat34& trn, const Twist& vb, Twist& v) const {
	trn.R.multiply(v.v, vb.v);
	trn.R.multiply(v.w, vb.w);
}

// Generic spatial jacobian generated from twist coordinates
void Chain::jacobianSpatial(const Real* cc, Twist* jac) const {
	Mat34 tmp, trn;

	const U32 numOfJoints = (U32)joints.size();
	trn.setId();

	jac[0] = joints[0]->getTrn().twist;
	for (U32 i = 1; i < numOfJoints; ++i) {
		tmp.fromTwist(joints[i - 1]->getTrn().twist, cc[i - 1]);
		trn.multiply(trn, tmp);
		trn.adjointTransform(jac[i], joints[i]->getTrn().twist);
	}
}

// Generic body jacobian generated from twist coordinates
void Chain::jacobianBody(const Real* cc, Twist* jac) const {
	Mat34 tmp, trn;

	const I32 numOfJoints = (I32)joints.size();
	trn = joints[numOfJoints - 1]->getTrnInit();
	
	for (I32 i = numOfJoints - 1; i >= 0; --i) {
		tmp.fromTwist(joints[i]->getTrn().twist, cc[i]);
		trn.multiply(tmp, trn);
		trn.adjointInverseTransform(jac[i], joints[i]->getTrn().twist);
	}
}

// Generic jacobian generated from twist coordinates
void Chain::jacobian(const Real* cc, Twist* jac) const {
	Chain::jacobianSpatial(cc, jac);
}

void Chain::jacobianFromSpatial(const Twist* jacs, const Mat34& trn, Twist* jac) const {
	const U32 numOfJoints = (U32)joints.size();
	const Vec3 p = trn.p;
	
	for (U32 i = 0; i < numOfJoints; ++i) {
		const Twist s = jacs[i];
		
		jac[i].set(
			s.v.v1 + p.v3*s.w.v2 - p.v2*s.w.v3,
			s.v.v2 - p.v3*s.w.v1 + p.v1*s.w.v3,
			s.v.v3 + p.v2*s.w.v1 - p.v1*s.w.v2,
			s.w.v1, s.w.v2, s.w.v3
		);
	}
}

void Chain::jacobianFromBody(const Twist* jacb, const Mat34& trn, Twist* jac) const {
	const U32 numOfJoints = (U32)joints.size();
	const Mat33 R = trn.R;
	
	for (U32 i = 0; i < numOfJoints; ++i) {
		const Twist b = jacb[i];
		
		jac[i].set(
			R.m11*b.v.v1 + R.m12*b.v.v2 + R.m13*b.v.v3,
			R.m21*b.v.v1 + R.m22*b.v.v2 + R.m23*b.v.v3,
			R.m31*b.v.v1 + R.m32*b.v.v2 + R.m33*b.v.v3,
			R.m11*b.w.v1 + R.m12*b.w.v2 + R.m13*b.w.v3,
			R.m21*b.w.v1 + R.m22*b.w.v2 + R.m23*b.w.v3,
			R.m31*b.w.v1 + R.m32*b.w.v2 + R.m33*b.w.v3
		);
	}
}

//------------------------------------------------------------------------------
